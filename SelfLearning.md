# Java

[toc]

## 基础

* 简单性, `C++`的纯净版本

* 面向对象, Java采用接口的方式替代多重继承

* 分布式, `Java`有一个丰富的例程库, 用于处理`HTTP`等网络请求和协议

* 健壮性, 没有指针

* 安全性, 防范各种攻击

* 体系结构中立, 编译器生成与特定计算机体系结构无关的**字节码**, 将这个字节码在虚拟机(`Java`运行时系统)上进行运行

* 可移植性, `Java`规范中没有依赖**具体实现**, 基本的数据类型大小以及相关运算都做了明确的说明

  | 类型   | 字节大小 |
  | ------ | -------- |
  | byte   | 1        |
  | short  | 2        |
  | int    | 4        |
  | long   | 8        |
  | float  | 4        |
  | double | 8        |
  
* 解释型, `Java`解释器可以在任何任何类型执行`Java`字节码

* 高性能, 字节码可以动态的翻译成对应运行这个应用

* 多线程

* 动态性, 将代码添加到正在运行的程序中.



## 基本程序设计结构

### 最简单的Java代码

```java
public class FirstSample {
    public static void main(String[] args) {
        System.out.println("Hello, World");
    }
}
```

* `public`称为**访问修饰符**, 这些修饰符用来控制程序的其它部分对这段代码的访问级别. 关键字`class`表明`Java`程序中的全部内容都包含在类中. `Java`应用程序中的全部内容都必须放置在类中.
* `Java`中定义类名的规则很宽松, **名字必须要以字母开头(标准是类名以大写字母开头, 如果名字由多个单词组成, 每个单词的第一个字母都应该大写)**
* 源代码对的文件名必须要和公共类的名字相同, 并以`.java`作为扩展
* 运行已编译的程序时, `Java`虚拟机将从指定类的`main`方法开始执行, 为了能让代码运行, 类的源文件必须要包含`main`方法

> C++注释:
>
> `Java`中所有函数都属于某个类方法, 因此`Java`中的`main()`方法必须有一个外壳类, `C++`中的静态成员函数, 这些成员函数定义在类的内部, 并且不对对象进行操作

### 注释

当需要注释的时候, 和`C++`一模带一样

```java
/**
*
*
*/
// 上面这种注释方式可以用来生成文档
```



### 数据类型

#### 整型

`Java`强数据类型语言, 除了刚开始描述的`Java`的数据大小之外, `Java`还有一个表示任意精度的算术包, 通常称为**大整数**, 属于`Java`的一个对象

> C++注释:
>
> 基本上和C++的使用方法差不太多, 但是`0b`或者`0B`开头可以用来表示二进制数

将`String`类型转成`Integer`可以调用`Integer.fromString`方法或者`Integer.parseInt()`方法

#### 浮点型

可以表示16进制浮点数, 例如`0x1.0p-3`表示`1 / 8`, 下面是用于表示溢出和出错情况:

* 正无穷大
* 负无穷大
* `NaN`

> 无法直接检测一个`NaN`是否相等, 所有的`NaN`的值也不一定是一样的一般采用`Double.isNaN`来判断一个数是否为`NaN`



#### `char`类型

`char`类型的值可以表示为16进制值, 范围从`\u0000`到`\uffff`

##### `Unicode`和`char`类型

码点是指一个编码表中的某个字符对应的代码值, 在`Unicode`标准中, 码点采用16进制书写, 并加上前缀`U+`.

在`Java`中`char`描述了`UTF-16`编码中的一个代码单元



#### `boolean`类型

> `Java`中boolean类型有着严格控制, 进行判断必须是`boolean`类型



### 变量

`Java`中的变量名以字母开头, 并由字母和数字构成的序列. 注意`$`也属于其中, 其余使用方法基本上同`C++`



#### 变量初始化

声明一个变量之后, 必须要用赋值语句对变量进行显式初始化

> `Java`不区分变量的声明和定义



#### 常量

采用关键字`final`指示常量, 表示这个变量只能被赋值一次, 一旦被赋值了, 就无法再更改了, 习惯上采用大写字母

如果想要一个常量在一个类中的多个方法中使用, 称为类常量, 可以使用关键字`static final`设置一个类常量



### 运算符

#### 数学函数和常量

`Math`类中包含了各种各样的数学函数:

* `Math.sqrt()`
* `Math.pow(x, a)`表示x的a次方
* `Math.floorMod(num, base)`表示一定为正数的除数取余
* 当然还有更多数学运算, 这里不再一一赘述

#### 数值类型之间的转换

混合计算的时候, 低精度首先向高精度进行扩展, `int`转换为`float`可能会有精度的不确定性, 丢失.

`Java`不允许窄缩, 但是可以将进行强制类型转换, 强制类型转换将直接阶段小数部分, 如果想要得到最接近的整数, 可以`Math.round()`

> 不要在`boolean`值和任何数值类型之间进行强制转换, 可以防止错误发生.

**虽然不允许直接进行窄缩, 但是运算过程中可以进行不同类型混用**



#### 移位运算符

> C++注释:
>
> `>>`和`<<`表示算术左移和右移, `>>>`表示逻辑右移

过多的移位会导致对移位数目进行取模运算



#### 运算符优先级

基本上和C++一致, 优先级最高位:`[] . ()`, 其余按照以往



### 枚举类型

基础用法和`C++`一致



### 字符串

`Java`字符串是`Unicode`字符序列, 每个采用`""`括起来的字符串都是`String`类型

#### 子串

`substring(m, n)`提取`m`到`n`的子串, 也就是**前闭后开区间**, 这一点是为了方便计算**子串长度**为**m - n**

#### 拼接

任何一个字符串和非字符串进行拼接的时候, **后者都会被转换为字符串**

如果需要把多个字符串放在一起, 用一个定界符分隔, 可以采用静态的`join`方法`String.join()`, 注意`join`中的每个参数都是**字符串**类型

#### 不可变的字符串

`String`类没有提供用于修改字符串的方法, 因此被称为**不可变字符串**

> `Java`字符串很像`const char*`, 因此不可以进行修改其中的内容

#### 检查相等

采用`s.equal(t)`来判断两个字符串中的值是否相等, **而`==`只能检测两个字符串的指向是否相同**

#### 空串和`Null`串

空串`""`是长度为0的字符串, 可以调用以下方式进行判断:

* `str.length() == 0`
* `str.equal("")`

空串是一个`Java`对象, 然而`String`变量还可以存放一个特殊值, 名为`null`, 表示没有任何对象与该变量关联, 要检查一个字符串为`null`, 可以使用以下条件:

* `if (str == null)`

#### 码点和码点单元

`char`数据类型是一个采用`UTF-16`编码表示`Unicode`码点的代码单元, 大多数的常用`Unicode`字符使用一个代码单元就可以表示

```java
String greeting = "Hello";
int cpCount = greeting.codePointCount(m, n); // 计算m到n码点的数目
char ch = greeting.charAt(n); // 查找为n的代码单元
```

#### 构建字符串

采用字符串连接的方式构建字符串效率表较低, 每次进行连接都会产生细心的`String`对象, 耗时由浪费空间, 采用`StringBuilder`可以避免类似问题

```java
StringBuilder builder = new StringBuilder();
builder.append();
builder.toString();
```



### 输入和输出

#### 读取输入

想要通过控制台进行输入, 首先需要构建一个`Scanner`对象, 并且和标准输入流`System in`相关联

```java
Scanner in = new Scanner(System.in); // 构建Scanner对象, 并和标准输入关联
String name = in.nextLine(); // 读取一行
String firstName = in.next(); // 读取一个单词
```

#### 格式化输出

沿用`C++`标准库中的`System.out.printf()`进行格式化输出

甚至可以采用格式化字符串的方法构建格式化字符串`String.format("", v1...);`

```java
"%n$Identifer"; // 表示格式化的参数, n从1开始
"%参数索引$标志 宽度.精度 t转换字符"
```

#### 文件输入和输出

```java
Scanner in = new Scanner(Paths.get("file.txt"), "UTF-8"); // 指定为UTF-8编码, 文件读取
PrintWriter out = new PrintWriter("path", "UTF-8"); // 
```



## 控制流程

和`C++`一模带一样, 不再进行赘述

* 不允许在重复声明同名变量



### 大数值

* `BigInteger`用于处理任意精度整数运算
* `BigDecimal`用于处理任意精度浮点数运算

```java
BigInteger big = BigInteger.valueOf();
```



### 数组

数组是一种数据结构, 可以通过整型下标来访问数组中的每一个值

```java
int[] a; // a是一个对象, 整型数组对象, 目前为null
a = new int [100]; // 赋值
int[] a = new int[100]; // 一步完成
```



#### `for each`循环

如果想要打印数组中的所有值, 可以采用`Arrays.toString`方法



#### 数组初始化

```java
T[] array = {} // 这种情况下不需要new
T[] array = new T T[] {} //
```



#### 数组拷贝

只不过是指针传递, 会导致指向同一个对象, 如果想要实现深度拷贝, 可以调用`Arrays`中的方法

**注意, 程序名并不会存在命令行参数当中**

#### 常规操作

* 数组排序
* `Math.random()`返回一个0-1之间的浮点数

### 多维数组

```java
T[][] balances; // 表示多维数组
balances = new T[m][n]; // 表示m行n列的数组
// 也可以采用直接初始化的方式进行初始化
```

`Java`实际上也是数组的数组



## 对象和类



### 类

`class`类是构造对象的模板和蓝图, 由类构造对象的过程称为创建类的实例

**封装**, 将数据和行为组合在一个包中, 并对对象的使用者隐藏了数据的实现方式, 对象中的数据称为**实例域**, 操纵数据的过程称为**方法**. 对于每个特定的类实例都有一组特定的实例域值, 这些值的集合就是这个对象当前的状态, 实现封装性的**关键在于绝对不能让类中的方法直接的访问其他类的实例域, 程序仅能通过对对象的方法和对象数据进行交互**

**继承**, 扩展一个类来建立一个新的类, `Java`所有的类都继承自`Object`类, 扩展一个类的时候, 新类具有所有扩展类的全部属性和方法.



#### 对象

对象的三个主要的特性:

* 对象的行为

  对象可以施加哪些方法

* 对象的状态

  对象如何响应, 主要指实例域

* 对象标识

  如何辨别具有不同行为和状态的对象, 每个对象都有一个唯一身份ID



#### 识别类

一般名词很可能是一个类



##### 类之间关系

* 依赖(`Use-a`), 如果一个类的方法操纵另一个类对象, 我们就叫做依赖
* 聚合(`has-a`), 如果类包含另一个类对象
* 继承(`is-a`), 一个继承自另一个类



### 使用预定义类

#### 对象和对象变量

采用**构造器**构造新实例



