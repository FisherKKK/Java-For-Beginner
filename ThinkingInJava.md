# Java编程思想

[toc]



## 面向对象导论

### 抽象过程

面向对象程序设计方式:

* 万物皆对象
* 程序是对象的集合, 通过发送消息告知彼此要做
* 每个对象都有自己由其它对象所构成的存储
* 每个对象都有类型
* 某一个特定类型对象都可以接受同样的消息

类描述了具有相同特性(数据元素)和行为(功能)的对象集合

### 隐藏具体

又被称为封装, 访问控制的第一个原因是让客户端程序员无法触及它们不应该触及的部分, 第二个原因是允许库设计者改变类内部工作方式而不用担心会影响客户端程序员

`Java`采用三个关键字(访问指定词)在类的内部设定边界:

* `public`, 表示对任何人都可用
* `private`, 表示除了类创建者和类型的内部方法之外任何人都不得访问
* `protected`, 表示继承的类可以访问`protected`成员, 但是无法访问`private`成员
* `默认`, 如果没有使用任何上述指定词, 将使用默认**包访问权限**, 类可以访问在同一个包中的其它类成员, 但是包之外的如同指定了`private`一样

### 复用具体实现

聚合, 经常被视为`has-a`关系

### 继承

以现有的类为基础, 通过添加和修改这个副本来创建新类. 当基类, 父类发生变化时, 导出类, 子类也会反映这种变化.

基类型包含其所有导出类所共享的特性和行为, 两种方法可以时基类和导出类发生差异:

* 直接在导出类中添加新方法
* `overriding`覆盖这个函数

#### "是一个"和"像一个"

`is-a`只是覆盖基类函数, `is-like-a`添加新的接口.



### 伴随多态的可互换对象

前期绑定, 编译器产生一个具体函数名字的调用, 运行时将这个调用解析到要被执行的代码和绝对地址

后期绑定, 被调用的代码直到运行的时候才能确定, 编译器确保被调用方法的存在, 并对调用参数和返回值执行类型检查

`Java`时默认动态绑定的, 而`C++`不是

将导出类看作是它基类的过程称为**向上转型**



### 单根继承结构



### 容器

`Java`标准库



## 一切都是对象

### 采用引用操纵对象

一切都被视为对象, 但是实际上操纵的是对象的**引用**. 其实就是一个遥控器来操纵电视, 即使没有电视机, 遥控器也可以单独存在, 也就是只创建一个引用.  也就是说遥控器就是引用, 而电视机就是对应的对象.

### 必须由你创建所有对象

一旦创建了引用, 就希望它与一个新的对象关联, 通常采用`new`操作符实现这一个目的, 因此会有如下表达式:

```java
String s = "Hello";
String s = new String("Hello");
```

#### 存储在什么地方

1. 寄存器, 最快的处理速度.
2. 栈, 位于`RAM`中, 一般来说`Java`的对象的引用存储在其中
3. 堆, 用于存储`Java`对象
4. 常量存储, `ROD`区
5. 持久化存储, 例如数据库, 磁盘等

#### 基本类型

对于一些特别下的变量, 比如基本类型, 采用直接存储值的方式, 存储在**栈**中, 这个并非是创建了引用.

注意一点`char`是**16**位.

基本数据类型具有包装器类, 使得可以在堆中创建一个非基本对象, 并且支持自动包装机制

#### Java中的数组

当创建一个数组对象的时候, 实际上创建了一个引用数组, 每个引用都会自动初始化值为`null`, `Java`一旦看见了`null`就知道这个引用还没有指向某个对象, 在运行过程中就会报错.



### 永远不需要销毁对象

#### 作用域

作用域决定了变量名的可见性和声明周期, 作用域里定义的变量只可用在作用域结束之前. `Java`不允许在同一个域类重复定义一个同名变量

#### 对象的作用域

`Java`对象不具备和基本类型一样的声明周期, 当`new`一个对象的时候, 它可以存活在作用域之外

```java
{
    String s = new String("a string");
} // end of scope
```

引用`s`在作用域终点就消失了, 但是`s`指向的`String`对象仍然占据内存空间. 事实上, 由`new`创建的对象只要你需要, 就会一直保留下去. 但是由于`Java`的**垃圾回收器**, 监视`new`产生的所有对象, 会自动释放不再使用的对象

###  创建新的数据类型: 类

`class`关键字创建一个类, 我们需要通过`new`来产生一个类对象实例

#### 字段和方法

类中有两种类型元素:

* 字段又被称为数据成员或实例域或者成员变量
* 方法又被称为成员函数

##### 基本成员默认值

**若类的某个成员是基本数据类型, 即使没有进行初始化, `Java`也会确保它获得默认值, 一般都是`0`. `C++`**则没有类似的功能, **只有当变量作为类成员使用的时候才会有如下效果**, 然而上述确保初始化的方法**不适用于*局部变量*(即非某个类的字段, 比如在类的方法中定义的, 这种变量的值可以为任意类型), 如果局部变量未被初始化就被使用, 那么`Java`将会报错**



### 方法, 参数和返回值

`Java`采用方法描述函数, 方法组成包括: 名称, 参数列表, 返回值, 方法体. 返回类型是在调用方法之后从方法返回的值, 参数列表给出了要传给方法的信息的类型和名称. 方法名和参数列表共同构成了函数的特征标, 也称为方法签名. 

`Java`中的方法只能作为类的一部分, 方法只有通过对象才能被调用



#### 参数列表

`Java`中任何传递对象的场合都是传递**引用**, 字符串中每个字符的尺寸都是

个字节



### 构建一个`Java`程序

#### 名字可见性

`Java`采用了一种全新方式解决名字冲突, 包名都是小写, 域名反转. 同一个文件内的每个类都有唯一的标识符

#### 运用其他控件

可以使用`import`来准确地告诉编译器你想要什么类, `import`指示编译器导入一个包, 也就是一个类库

#### `static`关键字

创建`class`时并没有分配内存, 执行`new`来创建对象时, 数据存储空间才被分配.

有两种情形是上述方法无法解释的:

* 只想为某特定域分配单一存储空间, 而不去考虑究竟要创建多少对象, 甚至根本不创建任何对象
* 希望某个方法与包含它的类的任何对象关联在一起, 也就是说即使没有创建对象也能调用方法.

通过`static`关键字可以满足. 当声明一个事物是`static`, 意味着这个域或方法不会与. 包含与它的那个类的任何对象实例关联在一起. 所以即使从未创建某个类的任何对象, 也可以调用其`static`方法或者访问`static`域. **通常你必须创建一个对象, 并用它来访问数据或方法, 因为非`static`域和方法必须要知道和它们一起运作的特定对象.**

```java
class StaticTest {
    static int i = 47;
}

StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
// 两个对象的i指向同一片内存空间, 所有对象共享一份i, 可以通过类名或者对象(虽然可以, 但是我们很少这样做)来获取它
```

类似的逻辑也可用于静态方法, 但是一般我们总是采用`ClassName.method`来使用类方法

`static`作用于某个字段的时候, 肯定会改变数据创建的方式(`static`只有一份存储空间, 非`static`则会有多个副本), 但是作用于方法的时候, 差别却没有那么大, `static`方法的一个重要用法就是可以不创建任何对象的时候就可以调用它. 



### 第一个`Java`程序

类的名字必须和文件名相同, `public`关键字意味着这是一个可由外部调用的方法



### 注释

基本同`C++`, 除了文档注释之外.

`javadoc`仅为`public`和`protected`成员进行文档注释





## 操作符

`==`对象的时候用来比较对象引用的地址, 基本类型又是另外一种. 如果想比较两个对象的实际内容, 应该使用`equals`特殊方法, 

一般来说`Java`不允许丢失精度的窄缩.



## 初始化与清理



### 用构造器确保初始化

构造器的名称必须要与类名完全相同, 不接受任何参数的构造器叫做**默认构造器**, 通常被称为**无参构造器.** 构造器是一种特殊的类型方法, 因为没有返回值



### 方法重载

#### 区分重载的方式

每个重载方法都必须要有一个独一无二的参数列表

#### 涉及基本类型的重载

返回值无法区分重载

### 默认构造器

默认构造器又名**无参构造器**, 没有参数, 如果没有写构造器, 编译器会自动加上. 但是已经定义了一个构造器, 编译器就不会自动帮你创建默认构造器

### `this`关键字

调用方法时, 实际上背后传入了参数`this`, 只不过编译自动优化了. `this`关键字只能在方法内部使用, 表示调用的那个对象.

一般一个函数返回自己本身, 会`return this;`

#### 在构造器中调用构造器

`this`关键字可以在一个构造器中调用另一个构造器. 但是要明白`this`不能调用两个构造器, 而且`this`必须要将构造器置于最起始的位置, 否则就会出错



#### `static`含义

`static`就是一个没有`this`的方法, 在`static`方法的内部不能调用非静态方法. 由于没有`this`上下文的原因



### 清理: 终结处理和垃圾回收

`finalize`方法用处不太大, 因此不具体考虑.

**垃圾回收的具体机制这里也不再进行考虑.**



### 成员初始化

`Java`尽力保证所有变量在初始化的时候都能得到恰当的初始化. 对于局部变量未初始化进行使用会导致编译错误. 如果是类的数据成员, 编译器会自动初始化, 如果是对象的话默认初始为`null`

#### 指定初始化

如果想为某个变量初始化, 可以直接在定义类成员变量的地方为其初始化, 也可以采用同样的方法初始化非基本类型对象, 甚至可以通过调用某个方法提供初始值. 但是一定要注意初始化顺序. 这会导致每个对象都具有相同的初始值.



## 构造器初始化

无法阻止自动初始化的进行, **它将在构造器调用之前发生**

#### 初始化顺序

在类的内部, 变量定义的先后顺序决定了初始化的顺序, **即使变量定义散布于方法定义之间, 它们仍然会在任何方法(包括构造器)被调用之前得到初始化**



#### 静态数据的初始化

`static`关键字不能作用于局部变量, 只用作用于域. 如果一个域是静态的基本类型, 也没有显式初始化, 那么就是基本类型的标准值, 如果是一个引用, 那么就是`null`.

静态初始化只有在必要的时刻才会进行, 如果不创建对象, 也不进行引用, 那么静态对象就不会被创建, 并且**被创建一次后不会再次被初始化**. 

初始化顺序是, 先静态对象(前提是尚未被初始化), 然后使非静态对象, 最后再是构造器函数中的初始化

总结一下一个类`Class`被创建的过程:

1. 即使没有显示的关键字, 构造器其实也是一个静态方法, 因此当首次创建类型为`Class`的对象的时候, 或者`Class`类的静态方法/静态域首次被访问的时候, `Java`解释器查找类路径, 定位`class`文件
2. 载入`class`文件, 所有静态初始化的动作都会执行, 因此静态初始化只在`Class`对象首次加载时进行一次
3. 当`new`一个对象的时候, 首先再堆上分配足够的存储空间
4. 这块内存区会自动地清零, 因此所有的基本类型都会设置成默认值0, 引用类型则被设置成`null`
5. 执行所有位于字段定义处的初始化动作
6. 执行构造器

####  显式的静态初始化

`Java`允许将多个静态初始化动作组织成一个特殊的静态子句(又被叫做**静态块**), 如下示例:

```java
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}
```

是一段跟在`static`关键字后面的代码, 这段代码仅执行一次; 当首次生成这个类的一个对象时或者首次访问那个类的静态数据成员时

#### 非静态实例初始化

和静态块基本上一模一样, 只是缺少了`static`关键字

```c++
public class Spoon {
    void print() {
        System.out.println("Hello World");
    }
}

class Spoons {
    Spoon s1;
    Spoon s1;
    {
        s1 = new Spoon();
        s2 = new Spoon();
        s2.print();
    }
}
```

这些实例初始化先于构造器执行



### 数组初始化

数组是相同类型的, 用一个标识符名称封装到一起的一个对象序列或者基本数据序列

```java
T[] array;
```

编译器不允许指定数组的大小. 现在拥有的只是对数组的引用(已经为该引用分配了空间), 而且也没有给数组对象本身分配任何空间. 为了给数组创建相应的存储空间, 必须写初始化表达式. 特殊的初始化可以采用花括号括起来.

```java
int[] a = {1, 2, 3, 4, 5};
```

所有数组都有一个固有成员, 可以通过它获知数组内包含了多少元素, `Java`数组越界会出现运行时错误, 可以动态地创建数组.



#### 可变参数列表

```java
static void printArray(Object... args) {
    for (Obejct obj: args) {
        
    }
}
```

有了可变参数列表, 就可以不用显式地编写数组



### 枚举类型

`enum`关键字枚举类型的实例是常量, 因此按照命名习惯都用大写字母表示



## 访问权限控制

`Java`提供了访问权限修饰词. 访问权限控制的等级, 从最大权限到最小权限依次为: `public`, `protected`, 包访问权限和`private`. `Java`用关键字`package`加以控制, 而访问权限修饰词会因类是存在于一个相同的包, 还是存在于一个单独二的包而受到影响. 

### 包: 库单元

包内包含一组类, 它们在单一的名字空间之下被组织在了一起. 使用`import`关键字, 如果你想要导入单个类, 可以在`import`语句中命名该类:

```java
import java.util.ArrayList;
import java.util.*;
```

### 代码组织

当编译一个`java`文件的时候, `.java`文件中的每一个类都会有一个输出文件, `class`后缀. 因此编译少量`.java`文件之后, 会得到大量`.class`文件. `Java`可运行程序是一组可以打包并压缩为`JAR`文档文件的`.class`文件. 

类库实际上是一组类文件, 其中每个文件都有一个`public`类, 以及任意数量的非`public`类, 如果希望这些构件从属于一个群组, 就可以使用关键字`package`

**如果使用`package`语句, 它必须是文件中除了注释以外的第一句程序代码**, 写为:

```java
package access;
```

就表明你在声明该编译单元为`access`类库的一部分, 也就是说你正在声明该编译单源中的`public`类名称是位于`access`名称下. 任何人想要使用该名称要么给定全名, 要么结合关键字`import`

#### 创建独一无二的包名

将`package`分解成你机器上一个个目录的名称, `Java`解释器运行过程如下:

* 首先找出环境变量`CLASSPATH`, 包含一个或者多个目录, 用作查找`.class`文件的根目录. `CLASSPATH`可以包含多个可供选择的查询路径. 但是在使用`JAR`时候, 必须要在类路径中将`JAR`文件实际写出来, 而不仅是指名所在



#### 用`import`改变行为

#### 对使用包的忠告

包要对应目录路径



### `Java`访问权限修饰词

缺省表示**包访问权限**

#### 包访问权限

意味着当前包中的所有其他类对那个成员都有访问权限, 对于这个包之外的所有类, 这个成员就是私有的. 由于一个编译单元(即一个文件)只能隶属于一个包, 所以经由包访问权限, 处于同一个编译单元中的所有类型彼此之间都是自动可访问的.

取得对某成员的访问权的唯一途径是:

* 使该成员称为`public`, 无论在哪都可以访问该成员
* 通过不加访问修饰词并将其他类放置于同一个包内的方式给成员赋予包访问权
* 继承, 继承而来的类即可以访问`public`成员, 也可以访问`protected`成员(`private`不行).
* 提供`getter`和`setter`读取和改变数值



#### `public`: 接口访问权限

#### `private`你无法访问

除了包含该成员的类之外, 其它任何类都无法访问这个成员. 由于处于同一个包内的其他类是不可以访问`private`成员的, 因此等于说是自己隔离了自己

#### `protected`继承访问权限

`protected`也提供包访问权限, 也就是说相同包内的其它类也可以访问`protected`元素



### 接口和实现

权限访问控制被称为具体实现隐藏, 也被称为**封装**



### 类的访问权限

`public`关键字作用域整个类使得类是可见的. 但是有一些限制:

* 每个编译单元都只能有一个`public`类
* 名字匹配
* 类不可以是`private`的, 也不可以是`protected`的, 所以类仅有`public`和包访问权限两种选择
* 如果不希望任何其它人对该类有访问权限, 可以把构造器指定为`private`, 从而阻止别人创建



## 复用类

### 组合 `has-a`

`toString`是对象都具有的一个函数, 当编译器需要一个`String`时, 会被自动调用

### 继承语法

所有类都隐式地从`Java`标准根类`Object`中进行继承

即使一个程序含有多个类, 每个类中都有若干`main`, 只有命令行调用的那个`main`会被调用



### 初始化基类

当创建了一个导出类的对象时, 该对象包含了一个基类的子对象. 这个子对象与你用基类直接创建的对象是一样的. 二者的区别在于后者来源于外部, 而基类的子对象被包装在导出类对象内部

基类子对象的正确初始化至关重要, **在构造器函数中调用基类构造器来执行初始化, 而基类构造器具有执行基类初始化所需要的所有知识和能力. `Java`**会自动在导出类的构造器中插入对基类构造器的调用.

##### 带参数的构造器

如果没有默认的基类构造器, 或者想要调用一个带参数的基类构造器, 就必须用关键字`super`显式的编写调用基类构造器的语句, 并且配上适当的参数列表



#### 名称屏蔽

如果`Java`的基类拥有某个已经被多次重载的方法名称, 那么在导出类中重新定义该方法名称并不会屏蔽其基类中的任何版本. 因此无论是该层还是基类中对方法进行定义, 重载都可以进行. 一般重写的时候添加注解



### `protected`关键字

指明就类用户而言, 这是`private`的, 但是对于任何继承于此类的导出类或任何位于同一个包内的类来说, 它却是可以访问的.



### 向上转型

新类是现有类的一种方式, 也就是为了体现多态的概念, 可以将导出类转化为基类

#### 为什么称为向上转型

将导出类转化为基类被称为**向上转型**, 相反也可以执行向下转型

#### 再论继承和组合

一个最清晰的方法判断自己需不需要继承就是问问自己是否需要进行向上转型, 是否需要采用多态, 否则继承就是不必要的.

### `final`关键字

表示这是无法改变的, `final`有三种作用情况, 数据, 方法和类

#### `final`数据

1. 一个永不改变的编译时常量
2. 一个在运行时被初始化的值, 而你不希望它被改变

对于编译器常量来讲, 编译器可以将该常量带入任何可能用到它的计算式中, 也就是说可以在编译时执行计算式. 在`Java`中这类常量必须时基本数据类型, 并且以关键字`final`表示

> 一个既是`static`又是`final`的域只占据一段不能改变的存储空间 `static final`

对于基本数据类型, `final`使数值恒定不变, 对于对象,  `final`引用恒定不变, 一旦引用被初始化就无法改变指向了

并不是说某数据是`final`就意味着在编译时就可以知道它的值

##### 空白`final`

`Java`允许生成空白`final`, 也就是初始化声明为`final`但是又没有给定初始值的域

> 也就是说如果`final`只是声明而没有进行初始化, 那么你可以初始化一次, 但是仅可以初始化一次

##### `final`参数

`Java`允许在参数列表中以声明的方式将参数指定为`final`, 这意味着你无法在方法中更改参数引用所指向的对象



#### `final`方法

有两个原因会使用这个方式:

* 把方法锁定, 防止任何继承类修改它的含义, 这是出于设计的考虑
* 还有就是效率, 可能以前是为了内联



##### `final`和`private`关键字

类中所有`private`方法都指定是`final`的, 由于无法取用`private`, 所以也就无法覆盖它. 如果你在导出类中添加了`private`同名的函数, 实际上是重新生成了一个新的函数, 这个函数不属于父类.



#### `final`类

当将某个类的整体定义为`final`时, 表明了你不打算继承该类, 也不允许别人这样做.

请注意, `final`类的域可以根据个人的意愿选择为是或不是`final`. 然而, 由于`final`类禁止继承, 所以`final`类中的所有方法都会隐式指定为`final`



#### 有关`final`忠告



### 初始化及类的加载

因为`Java`中所有的事物都是对象, 所以每个类的编译代码都存在于自己的独立文件中, 该文件旨在需要使用程序代码时才会被加载. 一般来说: "类的代码在初次独立使用时才被加载". 这通常指加载放生与创建第一个类对象时, 但是当访问`static`域或者`static`方法时也会放生加载.



#### 继承和初始化

继承时首先会加载基类(这时候会初始化`static`), 最后才会加载自己



## 多态

#### 方法调用绑定

将一个方法调用和一个方法主体关联起来被称为绑定. 若在程序执行前进行绑定, 叫做前期绑定, 也可以说时静态绑定. 动态绑定也叫做后期绑定, 也就是运行时根据对象的类型进行绑定.

`Java`中除了`static`方法和`final`方法, 其它所有方法都是自动后期绑定的, 将一个方法声明为` final`可以有效的关闭**动态绑定**



#### 缺陷: 覆盖私有方法

只有非`private`方法是可以覆盖的, `private`方法默认是`final`



#### 缺陷: 域与静态方法

只有普通的方法调用才可以是多态的, **域访问操作是编译器解析, 因此不是多态; 静态方法在编译之前绑定, 因此不是多态**



### 构造器和多态

**构造器默认也是`static`的**

#### 构造器调用的先后顺序

基类构造器总是在导出类的构造过程中被调用, 就是要将所有的基类都进入准备状态之后, 才能生成新的对象.

调用复杂对象调用构造器要遵照下面的顺序:

1. 调用基类构造器, 并不断迭代到根
2. 按照声明顺序进行初始化
3. 调用导出类构造器主体

构造器顺序很重要. 因此父类构造器只能在第一行调用, 因此不存在调用两次父类构造器.



#### 继承和清理



#### 构造器内部的多态方法的行为



### 协变返回类型

协变允许返回更加具体的类型



#### 向下转型与运行时类型识别

`Java`会进行转型检查, 这是在运行时进行的, 如果不正确, 会返回`ClassCastException`, 被称为`RTTI`



## 接口

### 抽象类和抽象方法

建立接口的唯一理由是, 不同的子类可以用不同的方式表示此接口. 通用接口建立起一种基本形式, 以此表示所有导出类的共同部分.

`Java`提供了一个叫做抽象方法的机制, 这种方法是不完整的, 仅有声明而没有方法体.

```java
abstract void f();
```

包含抽象方法的类叫做抽象类. 如果一个类包含一个或多个抽象方法, 该类必须限定为抽象的. 抽象类是不完整的, 当我们试图产生该类的对象的时候, 编译器会报错. 如果从一个抽象类继承, 并想创建该类的对象, 那么就必须为基类中所有的抽象方法提供类定义, 如果不这么做, 那么导出类便也是抽象类, 并且编译器强制用`abstract`关键字限定这个类



### 接口

`interface`关键字使抽象的概念更近一步, `abstract`关键字允许人们在类中创建一个或者多个没有任何定义的方法, 提供接口部分, 但是不提供任何对应的具体实现. `interface`关键字产生一个完全抽象类, 根本没有提供任何具体实现. 允许创建者确定方法名, 参数列表和返回类型, 但是没有任何方法体, 接口只提供形式, 而未提供任何具体实现.

因此任何使用特定接口的代码都知道可以调用该接口的哪些方法, 因此被用来建立类与类之间的协议.

`interface`允许人们向上转型, 从而实现多态.

```java
public interface Interface {
    // 方法声明
}

class Specification implements Interface {
    
}
```

接口默认是`public`



### `Java`中的多重继承

一个类只可以继承一个类, 但是可以实现多个接口

接口可以继承接口, 并且可以继承多个接口

#### 组合接口时的名字冲突

完全相同的函数不会有什么问题, 签名不一样重载, 返回类型不一样出错.



### 适配接口

接口最吸引人的地方在于允许同一个接口具有多个不同的具体实现

接受接口类型可以让任何类都对该方法进行适配

### 接口中的域

接口中的任何域自动都是`static`且`final`的, 所以接口是非常便捷创建常量的一组工具, 接口中的域自动是`public`的.

#### 初始化接口中的域

在接口中定义的域不能是空`final`的, 但是可以被非常量表达式初始化, 这些域不是接口的一部分, 它们的值被存储在该接口的静态存储区域内.

### 嵌套接口

接口可以嵌套在类或者其它接口中.



## 内部类





​                                                                        
