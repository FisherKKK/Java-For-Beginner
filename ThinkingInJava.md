# Java编程思想

[toc]



## 面向对象导论

### 抽象过程

面向对象程序设计方式:

* 万物皆对象
* 程序是对象的集合, 通过发送消息告知彼此要做
* 每个对象都有自己由其它对象所构成的存储
* 每个对象都有类型
* 某一个特定类型对象都可以接受同样的消息

类描述了具有相同特性(数据元素)和行为(功能)的对象集合

### 隐藏具体

又被称为封装, 访问控制的第一个原因是让客户端程序员无法触及它们不应该触及的部分, 第二个原因是允许库设计者改变类内部工作方式而不用担心会影响客户端程序员

`Java`采用三个关键字(访问指定词)在类的内部设定边界:

* `public`, 表示对任何人都可用
* `private`, 表示除了类创建者和类型的内部方法之外任何人都不得访问
* `protected`, 表示继承的类可以访问`protected`成员, 但是无法访问`private`成员
* `默认`, 如果没有使用任何上述指定词, 将使用默认**包访问权限**, 类可以访问在同一个包中的其它类成员, 但是包之外的如同指定了`private`一样

### 复用具体实现

聚合, 经常被视为`has-a`关系

### 继承

以现有的类为基础, 通过添加和修改这个副本来创建新类. 当基类, 父类发生变化时, 导出类, 子类也会反映这种变化.

基类型包含其所有导出类所共享的特性和行为, 两种方法可以时基类和导出类发生差异:

* 直接在导出类中添加新方法
* `overriding`覆盖这个函数

#### "是一个"和"像一个"

`is-a`只是覆盖基类函数, `is-like-a`添加新的接口.



### 伴随多态的可互换对象

前期绑定, 编译器产生一个具体函数名字的调用, 运行时将这个调用解析到要被执行的代码和绝对地址

后期绑定, 被调用的代码直到运行的时候才能确定, 编译器确保被调用方法的存在, 并对调用参数和返回值执行类型检查

`Java`时默认动态绑定的, 而`C++`不是

将导出类看作是它基类的过程称为**向上转型**



### 单根继承结构



### 容器

`Java`标准库



## 一切都是对象

### 采用引用操纵对象

一切都被视为对象, 但是实际上操纵的是对象的**引用**. 其实就是一个遥控器来操纵电视, 即使没有电视机, 遥控器也可以单独存在, 也就是只创建一个引用.  也就是说遥控器就是引用, 而电视机就是对应的对象.

### 必须由你创建所有对象

一旦创建了引用, 就希望它与一个新的对象关联, 通常采用`new`操作符实现这一个目的, 因此会有如下表达式:

```java
String s = "Hello";
String s = new String("Hello");
```

#### 存储在什么地方

1. 寄存器, 最快的处理速度.
2. 栈, 位于`RAM`中, 一般来说`Java`的对象的引用存储在其中
3. 堆, 用于存储`Java`对象
4. 常量存储, `ROD`区
5. 持久化存储, 例如数据库, 磁盘等

#### 基本类型

对于一些特别下的变量, 比如基本类型, 采用直接存储值的方式, 存储在**栈**中, 这个并非是创建了引用.

注意一点`char`是**16**位.

基本数据类型具有包装器类, 使得可以在堆中创建一个非基本对象, 并且支持自动包装机制

#### Java中的数组

当创建一个数组对象的时候, 实际上创建了一个引用数组, 每个引用都会自动初始化值为`null`, `Java`一旦看见了`null`就知道这个引用还没有指向某个对象, 在运行过程中就会报错.



### 永远不需要销毁对象

#### 作用域

作用域决定了变量名的可见性和声明周期, 作用域里定义的变量只可用在作用域结束之前. `Java`不允许在同一个域类重复定义一个同名变量

#### 对象的作用域

`Java`对象不具备和基本类型一样的声明周期, 当`new`一个对象的时候, 它可以存活在作用域之外

```java
{
    String s = new String("a string");
} // end of scope
```

引用`s`在作用域终点就消失了, 但是`s`指向的`String`对象仍然占据内存空间. 事实上, 由`new`创建的对象只要你需要, 就会一直保留下去. 但是由于`Java`的**垃圾回收器**, 监视`new`产生的所有对象, 会自动释放不再使用的对象

###  创建新的数据类型: 类

`class`关键字创建一个类, 我们需要通过`new`来产生一个类对象实例

#### 字段和方法

类中有两种类型元素:

* 字段又被称为数据成员或实例域或者成员变量
* 方法又被称为成员函数

##### 基本成员默认值

**若类的某个成员是基本数据类型, 即使没有进行初始化, `Java`也会确保它获得默认值, 一般都是`0`. `C++`**则没有类似的功能, **只有当变量作为类成员使用的时候才会有如下效果**, 然而上述确保初始化的方法**不适用于*局部变量*(即非某个类的字段, 比如在类的方法中定义的, 这种变量的值可以为任意类型), 如果局部变量未被初始化就被使用, 那么`Java`将会报错**



### 方法, 参数和返回值

`Java`采用方法描述函数, 方法组成包括: 名称, 参数列表, 返回值, 方法体. 返回类型是在调用方法之后从方法返回的值, 参数列表给出了要传给方法的信息的类型和名称. 方法名和参数列表共同构成了函数的特征标, 也称为方法签名. 

`Java`中的方法只能作为类的一部分, 方法只有通过对象才能被调用



#### 参数列表

`Java`中任何传递对象的场合都是传递**引用**, 字符串中每个字符的尺寸都是

个字节



### 构建一个`Java`程序

#### 名字可见性

`Java`采用了一种全新方式解决名字冲突, 包名都是小写, 域名反转. 同一个文件内的每个类都有唯一的标识符

#### 运用其他控件

可以使用`import`来准确地告诉编译器你想要什么类, `import`指示编译器导入一个包, 也就是一个类库

#### `static`关键字

创建`class`时并没有分配内存, 执行`new`来创建对象时, 数据存储空间才被分配.

有两种情形是上述方法无法解释的:

* 只想为某特定域分配单一存储空间, 而不去考虑究竟要创建多少对象, 甚至根本不创建任何对象
* 希望某个方法与包含它的类的任何对象关联在一起, 也就是说即使没有创建对象也能调用方法.

通过`static`关键字可以满足. 当声明一个事物是`static`, 意味着这个域或方法不会与. 包含与它的那个类的任何对象实例关联在一起. 所以即使从未创建某个类的任何对象, 也可以调用其`static`方法或者访问`static`域. **通常你必须创建一个对象, 并用它来访问数据或方法, 因为非`static`域和方法必须要知道和它们一起运作的特定对象.**

```java
class StaticTest {
    static int i = 47;
}

StaticTest st1 = new StaticTest();
StaticTest st2 = new StaticTest();
// 两个对象的i指向同一片内存空间, 所有对象共享一份i, 可以通过类名或者对象(虽然可以, 但是我们很少这样做)来获取它
```

类似的逻辑也可用于静态方法, 但是一般我们总是采用`ClassName.method`来使用类方法

`static`作用于某个字段的时候, 肯定会改变数据创建的方式(`static`只有一份存储空间, 非`static`则会有多个副本), 但是作用于方法的时候, 差别却没有那么大, `static`方法的一个重要用法就是可以不创建任何对象的时候就可以调用它. 



### 第一个`Java`程序

类的名字必须和文件名相同, `public`关键字意味着这是一个可由外部调用的方法



### 注释

基本同`C++`, 除了文档注释之外.

`javadoc`仅为`public`和`protected`成员进行文档注释





## 操作符

`==`对象的时候用来比较对象引用的地址, 基本类型又是另外一种. 如果想比较两个对象的实际内容, 应该使用`equals`特殊方法, 

一般来说`Java`不允许丢失精度的窄缩.



## 初始化与清理



### 用构造器确保初始化

构造器的名称必须要与类名完全相同, 不接受任何参数的构造器叫做**默认构造器**, 通常被称为**无参构造器.** 构造器是一种特殊的类型方法, 因为没有返回值



### 方法重载

#### 区分重载的方式

每个重载方法都必须要有一个独一无二的参数列表

#### 涉及基本类型的重载

返回值无法区分重载

### 默认构造器

默认构造器又名**无参构造器**, 没有参数, 如果没有写构造器, 编译器会自动加上. 但是已经定义了一个构造器, 编译器就不会自动帮你创建默认构造器

### `this`关键字

调用方法时, 实际上背后传入了参数`this`, 只不过编译自动优化了. `this`关键字只能在方法内部使用, 表示调用的那个对象.

一般一个函数返回自己本身, 会`return this;`

#### 在构造器中调用构造器

`this`关键字可以在一个构造器中调用另一个构造器. 但是要明白`this`不能调用两个构造器, 而且`this`必须要将构造器置于最起始的位置, 否则就会出错



#### `static`含义

`static`就是一个没有`this`的方法, 在`static`方法的内部不能调用非静态方法. 由于没有`this`上下文的原因



### 清理: 终结处理和垃圾回收

`finalize`方法用处不太大, 因此不具体考虑.

**垃圾回收的具体机制这里也不再进行考虑.**



### 成员初始化

`Java`尽力保证所有变量在初始化的时候都能得到恰当的初始化. 对于局部变量未初始化进行使用会导致编译错误. 如果是类的数据成员, 编译器会自动初始化, 如果是对象的话默认初始为`null`

#### 指定初始化

如果想为某个变量初始化, 可以直接在定义类成员变量的地方为其初始化, 也可以采用同样的方法初始化非基本类型对象, 甚至可以通过调用某个方法提供初始值. 但是一定要注意初始化顺序. 这会导致每个对象都具有相同的初始值.



## 构造器初始化

无法阻止自动初始化的进行, **它将在构造器调用之前发生**

#### 初始化顺序

在类的内部, 变量定义的先后顺序决定了初始化的顺序, **即使变量定义散布于方法定义之间, 它们仍然会在任何方法(包括构造器)被调用之前得到初始化**



#### 静态数据的初始化

`static`关键字不能作用于局部变量, 只用作用于域. 如果一个域是静态的基本类型, 也没有显式初始化, 那么就是基本类型的标准值, 如果是一个引用, 那么就是`null`.

静态初始化只有在必要的时刻才会进行, 如果不创建对象, 也不进行引用, 那么静态对象就不会被创建, 并且**被创建一次后不会再次被初始化**. 

初始化顺序是, 先静态对象(前提是尚未被初始化), 然后使非静态对象, 最后再是构造器函数中的初始化

总结一下一个类`Class`被创建的过程:

1. 即使没有显示的关键字, 构造器其实也是一个静态方法, 因此当首次创建类型为`Class`的对象的时候, 或者`Class`类的静态方法/静态域首次被访问的时候, `Java`解释器查找类路径, 定位`class`文件
2. 载入`class`文件, 所有静态初始化的动作都会执行, 因此静态初始化只在`Class`对象首次加载时进行一次
3. 当`new`一个对象的时候, 首先再堆上分配足够的存储空间
4. 这块内存区会自动地清零, 因此所有的基本类型都会设置成默认值0, 引用类型则被设置成`null`
5. 执行所有位于字段定义处的初始化动作
6. 执行构造器

####  显式的静态初始化

`Java`允许将多个静态初始化动作组织成一个特殊的静态子句(又被叫做**静态块**), 如下示例:

```java
public class Spoon {
    static int i;
    static {
        i = 47;
    }
}
```

是一段跟在`static`关键字后面的代码, 这段代码仅执行一次; 当首次生成这个类的一个对象时或者首次访问那个类的静态数据成员时

#### 非静态实例初始化

和静态块基本上一模一样, 只是缺少了`static`关键字

```c++
public class Spoon {
    void print() {
        System.out.println("Hello World");
    }
}

class Spoons {
    Spoon s1;
    Spoon s1;
    {
        s1 = new Spoon();
        s2 = new Spoon();
        s2.print();
    }
}
```

这些实例初始化先于构造器执行



### 数组初始化

数组是相同类型的, 用一个标识符名称封装到一起的一个对象序列或者基本数据序列

```java
T[] array;
```

编译器不允许指定数组的大小. 现在拥有的只是对数组的引用(已经为该引用分配了空间), 而且也没有给数组对象本身分配任何空间. 为了给数组创建相应的存储空间, 必须写初始化表达式. 特殊的初始化可以采用花括号括起来.

```java
int[] a = {1, 2, 3, 4, 5};
```

所有数组都有一个固有成员, 可以通过它获知数组内包含了多少元素, `Java`数组越界会出现运行时错误, 可以动态地创建数组.



#### 可变参数列表

```java
static void printArray(Object... args) {
    for (Obejct obj: args) {
        
    }
}
```

有了可变参数列表, 就可以不用显式地编写数组



### 枚举类型

`enum`关键字枚举类型的实例是常量, 因此按照命名习惯都用大写字母表示



## 访问权限控制

`Java`提供了访问权限修饰词. 访问权限控制的等级, 从最大权限到最小权限依次为: `public`, `protected`, 包访问权限和`private`. `Java`用关键字`package`加以控制, 而访问权限修饰词会因类是存在于一个相同的包, 还是存在于一个单独二的包而受到影响. 

### 包: 库单元

包内包含一组类, 它们在单一的名字空间之下被组织在了一起. 使用`import`关键字, 如果你想要导入单个类, 可以在`import`语句中命名该类:

```java
import java.util.ArrayList;
import java.util.*;
```

### 代码组织

当编译一个`java`文件的时候, `.java`文件中的每一个类都会有一个输出文件, `class`后缀. 因此编译少量`.java`文件之后, 会得到大量`.class`文件. `Java`可运行程序是一组可以打包并压缩为`JAR`文档文件的`.class`文件. 

类库实际上是一组类文件, 其中每个文件都有一个`public`类, 以及任意数量的非`public`类, 如果希望这些构件从属于一个群组, 就可以使用关键字`package`

**如果使用`package`语句, 它必须是文件中除了注释以外的第一句程序代码**, 写为:

```java
package access;
```

就表明你在声明该编译单元为`access`类库的一部分, 也就是说你正在声明该编译单源中的`public`类名称是位于`access`名称下. 任何人想要使用该名称要么给定全名, 要么结合关键字`import`

#### 创建独一无二的包名

将`package`分解成你机器上一个个目录的名称, `Java`解释器运行过程如下:

* 首先找出环境变量`CLASSPATH`, 包含一个或者多个目录, 用作查找`.class`文件的根目录. `CLASSPATH`可以包含多个可供选择的查询路径. 但是在使用`JAR`时候, 必须要在类路径中将`JAR`文件实际写出来, 而不仅是指名所在



#### 用`import`改变行为

#### 对使用包的忠告

包要对应目录路径



### `Java`访问权限修饰词

缺省表示**包访问权限**

#### 包访问权限

意味着当前包中的所有其他类对那个成员都有访问权限, 对于这个包之外的所有类, 这个成员就是私有的. 由于一个编译单元(即一个文件)只能隶属于一个包, 所以经由包访问权限, 处于同一个编译单元中的所有类型彼此之间都是自动可访问的.

取得对某成员的访问权的唯一途径是:

* 使该成员称为`public`, 无论在哪都可以访问该成员
* 通过不加访问修饰词并将其他类放置于同一个包内的方式给成员赋予包访问权
* 继承, 继承而来的类即可以访问`public`成员, 也可以访问`protected`成员(`private`不行).
* 提供`getter`和`setter`读取和改变数值



#### `public`: 接口访问权限

#### `private`你无法访问

除了包含该成员的类之外, 其它任何类都无法访问这个成员. 由于处于同一个包内的其他类是不可以访问`private`成员的, 因此等于说是自己隔离了自己

#### `protected`继承访问权限

`protected`也提供包访问权限, 也就是说相同包内的其它类也可以访问`protected`元素



### 接口和实现

权限访问控制被称为具体实现隐藏, 也被称为**封装**



### 类的访问权限

`public`关键字作用域整个类使得类是可见的. 但是有一些限制:

* 每个编译单元都只能有一个`public`类
* 名字匹配
* 类不可以是`private`的, 也不可以是`protected`的, 所以类仅有`public`和包访问权限两种选择
* 如果不希望任何其它人对该类有访问权限, 可以把构造器指定为`private`, 从而阻止别人创建



## 复用类

### 组合 `has-a`

